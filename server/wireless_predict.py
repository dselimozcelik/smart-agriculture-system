# -*- coding: utf-8 -*-
"""wireless_predict.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Oo66dcdX-FP-x5LY1kOaUBdIj_ehSq85
"""

#!pip install -q torch torchvision matplotlib

#!pip install flask  pillow flask-cors

from flask import Flask, request, render_template, jsonify
from flask_cors import CORS
from torchvision import models, transforms
from torchvision.models import ResNet18_Weights
import torch
import torch.nn as nn
from PIL import Image
import os
import base64
import io
import json
import paho.mqtt.client as mqtt
import threading
import time

app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

# MQTT Configuration
mqtt_server = "broker.hivemq.com"
mqtt_topic = "esp32/sensors"
sensor_data = {
    "temperature": 0,
    "humidity": 0,
    "ldr_analog": 0,
    "soil_moisture": 0,
    "timestamp": time.time()
}

# MQTT callbacks
def on_connect(client, userdata, flags, rc):
    print(f"Connected to MQTT broker with code {rc}")
    client.subscribe(mqtt_topic)
    print(f"Subscribed to topic: {mqtt_topic}")

def on_message(client, userdata, msg):
    global sensor_data
    try:
        payload = msg.payload.decode()
        print(f"Received: {payload}")
        data = json.loads(payload)
        # Update sensor data
        sensor_data = {
            "temperature": data.get("temperature", 0),
            "humidity": data.get("humidity", 0),
            "ldr_analog": data.get("ldr_analog", 0),
            "soil_moisture": data.get("soil_moisture", 0),
            "timestamp": time.time()
        }
    except Exception as e:
        print(f"Error processing MQTT message: {e}")

# Setup MQTT client
mqtt_client = mqtt.Client()
mqtt_client.on_connect = on_connect
mqtt_client.on_message = on_message

# Start MQTT client in a separate thread
def start_mqtt_client():
    try:
        mqtt_client.connect(mqtt_server, 1883, 60)
        mqtt_client.loop_forever()
    except Exception as e:
        print(f"MQTT connection error: {e}")
        time.sleep(5)  # Wait before retry

# üîÅ Model sƒ±nƒ±f isimleri
class_names = [
    "Apple___Apple_scab", "Apple___Black_rot", "Apple___Cedar_apple_rust", "Apple___healthy",
    "Blueberry___healthy", "Cherry_(including_sour)___Powdery_mildew", "Cherry_(including_sour)___healthy",
    "Corn_(maize)___Cercospora_leaf_spot Gray_leaf_spot", "Corn_(maize)___Common_rust_",
    "Corn_(maize)___Northern_Leaf_Blight", "Corn_(maize)___healthy", "Grape___Black_rot",
    "Grape___Esca_(Black_Measles)", "Grape___Leaf_blight_(Isariopsis_Leaf_Spot)", "Grape___healthy",
    "Orange___Haunglongbing_(Citrus_greening)", "Peach___Bacterial_spot", "Peach___healthy",
    "Pepper,_bell___Bacterial_spot", "Pepper,_bell___healthy", "Potato___Early_blight",
    "Potato___Late_blight", "Potato___healthy", "Raspberry___healthy", "Soybean___healthy",
    "Squash___Powdery_mildew", "Strawberry___Leaf_scorch", "Strawberry___healthy",
    "Tomato___Bacterial_spot", "Tomato___Early_blight", "Tomato___Late_blight",
    "Tomato___Leaf_Mold", "Tomato___Septoria_leaf_spot",
    "Tomato___Spider_mites Two-spotted_spider_mite", "Tomato___Target_Spot",
    "Tomato___Tomato_Yellow_Leaf_Curl_Virus", "Tomato___Tomato_mosaic_virus", "Tomato___healthy"
]

# üß† Modeli y√ºkle
print("Loading model...")
model = models.resnet18(weights=None)
model.fc = nn.Linear(model.fc.in_features, len(class_names))
model.load_state_dict(torch.load("best_model.pt", map_location="cpu", weights_only=True))
model.eval()
print("Model loaded successfully!")

# üîÑ G√∂rsel d√∂n√º≈ü√ºm√º
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
])

@app.route('/', methods=['GET', 'POST'])
def index():
    prediction = None
    if request.method == 'POST':
        file = request.files['image']
        if file:
            img = Image.open(file).convert("RGB")
            img_tensor = transform(img).unsqueeze(0)

            with torch.no_grad():
                outputs = model(img_tensor)
                _, pred = torch.max(outputs, 1)
                prediction = class_names[pred.item()]

    return render_template('index.html', prediction=prediction)

@app.route('/api/classify', methods=['POST'])
def classify_api():
    try:
        # Check if image is sent as a file or base64
        if 'image' in request.files:
            file = request.files['image']
            img = Image.open(file).convert("RGB")
        elif request.json and 'image' in request.json:
            # Decode base64 image
            image_data = request.json['image']
            if ';base64,' in image_data:
                # Remove the prefix if it exists (e.g., data:image/jpeg;base64,)
                image_data = image_data.split(';base64,')[1]
            img_data = base64.b64decode(image_data)
            img = Image.open(io.BytesIO(img_data)).convert("RGB")
        else:
            return jsonify({'error': 'No image provided'}), 400

        # Process image with model
        img_tensor = transform(img).unsqueeze(0)
        with torch.no_grad():
            outputs = model(img_tensor)
            probabilities = torch.nn.functional.softmax(outputs, dim=1)[0]
            _, pred = torch.max(outputs, 1)
            prediction = class_names[pred.item()]
            confidence = probabilities[pred].item() * 100

        # Determine if the plant is healthy
        is_healthy = "healthy" in prediction.lower()
        
        # Determine condition status
        if is_healthy:
            condition = "Healthy"
        elif "bacterial" in prediction.lower() or "black_rot" in prediction.lower():
            condition = "Critical - Disease detected"
        else:
            condition = "Warning - Potential disease"

        return jsonify({
            'prediction': prediction,
            'confidence': confidence,
            'is_healthy': is_healthy,
            'condition': condition
        })
    
    except Exception as e:
        print(f"Error: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/health', methods=['GET'])
def health_check():
    return jsonify({
        'status': 'ok',
        'model': 'ResNet18',
        'num_classes': len(class_names)
    })

@app.route('/api/sensors', methods=['GET'])
def get_sensor_data():
    return jsonify(sensor_data)

@app.route('/sensors', methods=['GET'])
def sensors_page():
    return render_template('sensors.html')

if __name__ == '__main__':
    os.makedirs('templates', exist_ok=True)
    
    # Create a simple index.html if it doesn't exist
    if not os.path.exists('templates/index.html'):
        with open('templates/index.html', 'w') as f:
            f.write('''
<!DOCTYPE html>
<html>
<head>
    <title>Plant Disease Classification</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        h1 { color: #2c3e50; }
        form { margin: 20px 0; }
        .result { margin-top: 20px; padding: 10px; border-radius: 5px; }
        .healthy { background-color: #d4edda; color: #155724; }
        .disease { background-color: #f8d7da; color: #721c24; }
        nav { margin-bottom: 20px; }
        nav a { margin-right: 15px; text-decoration: none; color: #3498db; }
    </style>
</head>
<body>
    <nav>
        <a href="/">Disease Detection</a>
        <a href="/sensors">Sensor Data</a>
    </nav>
    <h1>Plant Disease Classification</h1>
    <p>Upload an image of a plant to detect diseases.</p>
    
    <form method="POST" enctype="multipart/form-data">
        <input type="file" name="image" accept="image/*" required>
        <button type="submit">Analyze</button>
    </form>

    {% if prediction %}
    <div class="result {% if 'healthy' in prediction %}healthy{% else %}disease{% endif %}">
        <h3>Result: {{ prediction }}</h3>
    </div>
    {% endif %}
</body>
</html>
            ''')
    
    # Create sensors.html for visualizing sensor data
    if not os.path.exists('templates/sensors.html'):
        with open('templates/sensors.html', 'w') as f:
            f.write('''
<!DOCTYPE html>
<html>
<head>
    <title>Smart Agriculture Sensors</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 1000px; margin: 0 auto; padding: 20px; }
        h1 { color: #2c3e50; }
        .sensor-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-bottom: 30px; }
        .sensor-card { background-color: #f8f9fa; border-radius: 10px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .sensor-value { font-size: 2.5rem; font-weight: bold; margin: 10px 0; }
        .chart-container { height: 400px; margin-top: 30px; }
        nav { margin-bottom: 20px; }
        nav a { margin-right: 15px; text-decoration: none; color: #3498db; }
        .temp { color: #e74c3c; }
        .humidity { color: #3498db; }
        .light { color: #f39c12; }
        .soil { color: #27ae60; }
    </style>
</head>
<body>
    <nav>
        <a href="/">Disease Detection</a>
        <a href="/sensors">Sensor Data</a>
    </nav>
    <h1>Smart Agriculture Sensor Data</h1>
    
    <div class="sensor-grid">
        <div class="sensor-card">
            <h2>Temperature</h2>
            <div class="sensor-value temp" id="temperature">--</div>
            <div>¬∞C</div>
        </div>
        <div class="sensor-card">
            <h2>Humidity</h2>
            <div class="sensor-value humidity" id="humidity">--</div>
            <div>%</div>
        </div>
        <div class="sensor-card">
            <h2>Light Level</h2>
            <div class="sensor-value light" id="light">--</div>
            <div>lux</div>
        </div>
        <div class="sensor-card">
            <h2>Soil Moisture</h2>
            <div class="sensor-value soil" id="soil">--</div>
            <div>%</div>
        </div>
    </div>
    
    <div class="chart-container">
        <canvas id="sensorChart"></canvas>
    </div>

    <script>
        // Initialize chart with empty data
        const ctx = document.getElementById('sensorChart').getContext('2d');
        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    {
                        label: 'Temperature (¬∞C)',
                        data: [],
                        borderColor: '#e74c3c',
                        tension: 0.1,
                        fill: false
                    },
                    {
                        label: 'Humidity (%)',
                        data: [],
                        borderColor: '#3498db',
                        tension: 0.1,
                        fill: false
                    },
                    {
                        label: 'Light Level',
                        data: [],
                        borderColor: '#f39c12',
                        tension: 0.1,
                        fill: false
                    },
                    {
                        label: 'Soil Moisture (%)',
                        data: [],
                        borderColor: '#27ae60',
                        tension: 0.1,
                        fill: false
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Time'
                        }
                    },
                    y: {
                        beginAtZero: true
                    }
                }
            }
        });

        // Store historical data
        const historyData = {
            timestamps: [],
            temperature: [],
            humidity: [],
            light: [],
            soil: []
        };

        // Update sensor values
        function updateSensorValues() {
            fetch('/api/sensors')
                .then(response => response.json())
                .then(data => {
                    // Update display values
                    document.getElementById('temperature').textContent = data.temperature.toFixed(1);
                    document.getElementById('humidity').textContent = data.humidity.toFixed(1);
                    document.getElementById('light').textContent = data.ldr_analog;
                    document.getElementById('soil').textContent = data.soil_moisture;
                    
                    // Update history
                    const now = new Date();
                    const timeString = now.getHours() + ':' + now.getMinutes() + ':' + now.getSeconds();
                    
                    // Limit history to last 20 points
                    if (historyData.timestamps.length > 20) {
                        historyData.timestamps.shift();
                        historyData.temperature.shift();
                        historyData.humidity.shift();
                        historyData.light.shift();
                        historyData.soil.shift();
                    }
                    
                    historyData.timestamps.push(timeString);
                    historyData.temperature.push(data.temperature);
                    historyData.humidity.push(data.humidity);
                    historyData.light.push(data.ldr_analog);
                    historyData.soil.push(data.soil_moisture);
                    
                    // Update chart
                    chart.data.labels = historyData.timestamps;
                    chart.data.datasets[0].data = historyData.temperature;
                    chart.data.datasets[1].data = historyData.humidity;
                    chart.data.datasets[2].data = historyData.light;
                    chart.data.datasets[3].data = historyData.soil;
                    chart.update();
                })
                .catch(error => console.error('Error fetching sensor data:', error));
        }

        // Initial update and set interval
        updateSensorValues();
        setInterval(updateSensorValues, 2000); // Update every 2 seconds
    </script>
</body>
</html>
            ''')
    
    # Start MQTT client in a background thread
    mqtt_thread = threading.Thread(target=start_mqtt_client, daemon=True)
    mqtt_thread.start()
    
    print("Starting server on http://127.0.0.1:5001")
    app.run(debug=True, host='0.0.0.0', port=5001)